# NIAC-Go v1.2.0 Implementation Plan

**Goal**: Achieve 100% protocol feature parity with Java NIAC by implementing the 3 missing protocols.

**Target Timeline**: 2-3 weeks
**Status**: Planning Phase
**Created**: January 5, 2025

---

## Table of Contents

1. [Overview](#overview)
2. [Protocol 1: IPv6 + ICMPv6](#protocol-1-ipv6--icmpv6)
3. [Protocol 2: NetBIOS](#protocol-2-netbios)
4. [Protocol 3: Spanning Tree Protocol (STP)](#protocol-3-spanning-tree-protocol-stp)
5. [Integration and Testing](#integration-and-testing)
6. [Release Checklist](#release-checklist)

---

## Overview

### Current State (v1.1.0)
- **Implemented Protocols**: ARP, IP, ICMP, TCP, UDP, HTTP, FTP, DNS (stub), DHCP (stub), SNMP
- **Missing from Java**: IPv6, ICMPv6, NetBIOS, Spanning Tree
- **Code Size**: 6,216 lines
- **Feature Parity Score**: 10/13 categories (77%)

### Target State (v1.2.0)
- **All Protocols**: Add IPv6, ICMPv6, NetBIOS, STP
- **Estimated Code**: +1,500 lines (~7,700 total)
- **Feature Parity Score**: 13/13 categories (100%)
- **Status**: **Definitively superior to Java in ALL categories**

---

## Protocol 1: IPv6 + ICMPv6

**Priority**: HIGHEST (most commonly needed)
**Complexity**: HIGH (largest implementation)
**Estimated Time**: 1-1.5 weeks
**Lines of Code**: ~600-800 lines

### Java Implementation Analysis

**File**: `niac-java/src/fluke/niac/protocols/Ip6.java` (~500 lines)

#### IPv6 Header Structure
```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Version| Traffic Class |           Flow Label                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Payload Length        |  Next Header  |   Hop Limit   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                                                               |
+                         Source Address                        +
|                                                               |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                                                               |
+                      Destination Address                      +
|                                                               |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

**Header Size**: 40 bytes (fixed, no options like IPv4)

#### Key Features to Implement

1. **Basic IPv6 Packet Handling**
   - Version field: 6
   - Traffic Class: QoS/DSCP
   - Flow Label: 20-bit identifier
   - Payload Length: excludes 40-byte header
   - Next Header: identifies next protocol (like IPv4 Protocol field)
   - Hop Limit: like IPv4 TTL

2. **Extension Headers Chain**
   Java parses extension headers to find actual Layer 4 protocol:
   - Hop-by-Hop Options (0)
   - Routing Header (43)
   - Fragment Header (44)
   - Destination Options (60)
   - Authentication Header (51)
   - ESP Header (50)
   - No Next Header (59)

3. **IPv6 Addresses**
   - 128-bit addresses (16 bytes)
   - Special addresses:
     - `ff02::1` - All nodes multicast
     - `ff02::2` - All routers multicast
     - `::/128` - Unspecified address
     - `::1/128` - Loopback

4. **Multicast MAC Mapping** (RFC 2464)
   ```
   IPv6 multicast → Ethernet multicast
   ff02::1234:5678 → 33:33:56:78

   Formula: 33:33:XX:XX:XX:XX (last 4 bytes of IPv6)
   ```

5. **Checksum Calculation**
   Uses pseudo-header (like IPv4):
   ```
   Pseudo-header:
   - Source IPv6 (16 bytes)
   - Dest IPv6 (16 bytes)
   - Payload length (4 bytes)
   - Next header (4 bytes, zero-padded)
   ```

### ICMPv6 Implementation

**File**: `niac-java/src/fluke/niac/protocols/Icmp6.java` (~500 lines)

#### ICMPv6 Message Types

**Error Messages** (type < 128):
- Type 1: Destination Unreachable
- Type 2: Packet Too Big
- Type 3: Time Exceeded
- Type 4: Parameter Problem

**Informational Messages** (type >= 128):
- Type 128: Echo Request (ping6)
- Type 129: Echo Reply
- Type 133: Router Solicitation
- Type 134: Router Advertisement
- Type 135: Neighbor Solicitation (like ARP)
- Type 136: Neighbor Advertisement
- Type 137: Redirect

#### Key ICMPv6 Features

1. **Neighbor Discovery Protocol (NDP)** - Replaces ARP
   - Neighbor Solicitation: "Who has IPv6 address X?"
   - Neighbor Advertisement: "I have IPv6 address X, my MAC is Y"
   - Uses multicast instead of broadcast

2. **Router Discovery**
   - Router Solicitation: "Any routers here?"
   - Router Advertisement: "I'm a router, here's my prefix"

3. **Echo Request/Reply** - Like ICMP ping
   - Same as IPv4 ICMP echo

4. **Options**
   - Source Link-Layer Address (type 1)
   - Target Link-Layer Address (type 2)
   - Prefix Information (type 3)
   - MTU (type 5)

### Implementation Steps

#### Step 1: Create IPv6 Handler (`pkg/protocols/ipv6.go`)

```go
package protocols

import (
	"net"
	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
)

// IPv6 protocol constants
const (
	IPv6HeaderSize = 40

	// Next Header values (same as IPv4 protocol numbers)
	IPv6NextHeaderHopByHop = 0
	IPv6NextHeaderTCP      = 6
	IPv6NextHeaderUDP      = 17
	IPv6NextHeaderICMPv6   = 58
	IPv6NextHeaderNoNext   = 59
)

// IPv6 special addresses
var (
	AllNodesMulticast   = net.ParseIP("ff02::1")
	AllRoutersMulticast = net.ParseIP("ff02::2")
)

type IPv6Handler struct {
	stack *Stack
}

func NewIPv6Handler(stack *Stack) *IPv6Handler {
	return &IPv6Handler{stack: stack}
}

func (h *IPv6Handler) HandlePacket(packet gopacket.Packet) error {
	// Extract IPv6 layer
	ipv6Layer := packet.Layer(layers.LayerTypeIPv6)
	if ipv6Layer == nil {
		return fmt.Errorf("no IPv6 layer")
	}

	ipv6 := ipv6Layer.(*layers.IPv6)

	// Handle based on next header
	switch ipv6.NextHeader {
	case layers.IPProtocolICMPv6:
		return h.stack.icmpv6Handler.HandlePacket(packet)
	case layers.IPProtocolUDP:
		return h.stack.udpHandler.HandlePacket(packet)
	case layers.IPProtocolTCP:
		return h.stack.tcpHandler.HandlePacket(packet)
	default:
		// Unsupported next header
		return nil
	}
}

// IPv6MulticastToMAC converts IPv6 multicast to Ethernet multicast
// RFC 2464: 33:33 + last 4 bytes of IPv6
func IPv6MulticastToMAC(ipv6 net.IP) net.HardwareAddr {
	mac := make(net.HardwareAddr, 6)
	mac[0] = 0x33
	mac[1] = 0x33
	copy(mac[2:], ipv6[12:16])
	return mac
}
```

#### Step 2: Create ICMPv6 Handler (`pkg/protocols/icmpv6.go`)

```go
package protocols

import (
	"fmt"
	"net"
	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
)

type ICMPv6Handler struct {
	stack *Stack
}

func NewICMPv6Handler(stack *Stack) *ICMPv6Handler {
	return &ICMPv6Handler{stack: stack}
}

func (h *ICMPv6Handler) HandlePacket(packet gopacket.Packet) error {
	icmpv6Layer := packet.Layer(layers.LayerTypeICMPv6)
	if icmpv6Layer == nil {
		return fmt.Errorf("no ICMPv6 layer")
	}

	icmpv6 := icmpv6Layer.(*layers.ICMPv6)

	switch icmpv6.TypeCode.Type() {
	case layers.ICMPv6TypeEchoRequest:
		return h.handleEchoRequest(packet)
	case layers.ICMPv6TypeNeighborSolicitation:
		return h.handleNeighborSolicitation(packet)
	case layers.ICMPv6TypeRouterSolicitation:
		return h.handleRouterSolicitation(packet)
	default:
		// Silently drop other types
		return nil
	}
}

func (h *ICMPv6Handler) handleEchoRequest(packet gopacket.Packet) error {
	// Similar to ICMP echo, but for IPv6
	// 1. Find device by destination IPv6
	// 2. Swap src/dst IPv6 and MAC
	// 3. Change type to Echo Reply (129)
	// 4. Recalculate checksum
	// 5. Send response
}

func (h *ICMPv6Handler) handleNeighborSolicitation(packet gopacket.Packet) error {
	// NDP - like ARP for IPv6
	// 1. Extract target IPv6 from solicitation
	// 2. Find device with that IPv6
	// 3. Build Neighbor Advertisement with device's MAC
	// 4. Send response
}

func (h *ICMPv6Handler) handleRouterSolicitation(packet gopacket.Packet) error {
	// Router Advertisement
	// Only respond if device is configured as router
	// Include prefix information, MTU, etc.
}
```

#### Step 3: Update Device Configuration

**File**: `pkg/config/config.go`

```go
type Device struct {
	Name         string
	Type         string
	IPAddresses  []net.IP
	IPv6Addresses []net.IP  // ADD THIS
	MACAddress   net.HardwareAddr
	SNMPConfig   SNMPConfig
	// ... existing fields
}
```

#### Step 4: Update Protocol Stack

**File**: `pkg/protocols/stack.go`

```go
type Stack struct {
	// ... existing handlers
	ipv6Handler   *IPv6Handler   // ADD
	icmpv6Handler *ICMPv6Handler // ADD
}

func (s *Stack) HandlePacket(packet gopacket.Packet) error {
	// ... existing code

	// Check for IPv6
	if packet.Layer(layers.LayerTypeIPv6) != nil {
		return s.ipv6Handler.HandlePacket(packet)
	}

	// ... rest of existing code
}
```

#### Step 5: Testing Strategy

1. **Unit Tests** (`pkg/protocols/ipv6_test.go`, `pkg/protocols/icmpv6_test.go`)
   - Test IPv6 packet parsing
   - Test extension header walking
   - Test multicast MAC mapping
   - Test ICMPv6 echo request/reply
   - Test Neighbor Discovery

2. **Integration Tests**
   - Send real ping6 packets
   - Test NDP (IPv6 ARP equivalent)
   - Test Router Advertisement

3. **Example Config**
   ```cfg
   device router1
       type router
       ip 192.168.1.1
       ipv6 fe80::1
       ipv6 2001:db8::1
       mac 00:11:22:33:44:55
       snmp public
   end
   ```

### Estimated Breakdown

| Task | Lines of Code | Time | Priority |
|------|---------------|------|----------|
| IPv6 handler skeleton | 100 | 2 hours | 1 |
| IPv6 extension header parsing | 150 | 4 hours | 2 |
| ICMPv6 handler skeleton | 100 | 2 hours | 3 |
| Echo Request/Reply | 100 | 2 hours | 4 |
| Neighbor Discovery (NDP) | 200 | 6 hours | 5 |
| Router Advertisement | 150 | 4 hours | 6 |
| Config file updates | 50 | 2 hours | 7 |
| Unit tests | 200 | 6 hours | 8 |
| Integration tests | 100 | 4 hours | 9 |
| **Total** | **~1,150** | **32 hours** | |

---

## Protocol 2: NetBIOS

**Priority**: MEDIUM
**Complexity**: MEDIUM
**Estimated Time**: 3-5 days
**Lines of Code**: ~300-400 lines

### Overview

NetBIOS (Network Basic Input/Output System) provides three services:
1. **Name Service** - UDP port 137 (name registration/resolution)
2. **Datagram Service** - UDP port 138 (connectionless communication)
3. **Session Service** - TCP port 139 (connection-oriented communication)

### Java Implementation Search

Need to find NetBIOS implementation in Java NIAC:
```bash
grep -r "NetBIOS" niac-java/
grep -r "137\|138\|139" niac-java/
```

### NetBIOS Name Service (Port 137)

#### Packet Format
```
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          NAME_TRN_ID          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|FLAGS|  QDCOUNT  |  ANCOUNT    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  NSCOUNT      |  ARCOUNT      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

**Query Types**:
- Name Query (0x0020) - "Who is WORKSTATION?"
- Name Registration (0x2820) - "I am WORKSTATION"
- Name Release (0x3020) - "I'm no longer WORKSTATION"

#### NetBIOS Name Encoding
NetBIOS names are 16 bytes, encoded as 32 bytes:
```
"WORKSTATION" → "EFFEECEFEDCACACACACACACACACAAA"
(each nibble encoded as ASCII A-P)
```

### Implementation Plan

#### Step 1: NetBIOS Name Service Handler

**File**: `pkg/protocols/netbios.go`

```go
package protocols

const (
	NetBIOSNamePort     = 137
	NetBIOSDatgramPort  = 138
	NetBIOSSessionPort  = 139
)

type NetBIOSHandler struct {
	stack *Stack
}

func NewNetBIOSHandler(stack *Stack) *NetBIOSHandler {
	return &NetBIOSHandler{stack: stack}
}

func (h *NetBIOSHandler) HandleNameQuery(packet gopacket.Packet) error {
	// 1. Parse NetBIOS name query
	// 2. Decode NetBIOS name (32-byte → 16-byte)
	// 3. Find device with that NetBIOS name
	// 4. Build name query response with device IP
	// 5. Send response
}

func encodeNetBIOSName(name string) string {
	// Encode 16-byte name to 32-byte ASCII
}

func decodeNetBIOSName(encoded string) string {
	// Decode 32-byte ASCII to 16-byte name
}
```

#### Step 2: Update Device Config

```go
type Device struct {
	// ... existing fields
	NetBIOSName string // ADD: e.g., "WORKSTATION"
}
```

### Estimated Breakdown

| Task | Lines of Code | Time | Priority |
|------|---------------|------|----------|
| NetBIOS name encoding/decoding | 100 | 3 hours | 1 |
| Name query handler | 100 | 3 hours | 2 |
| Name registration response | 80 | 2 hours | 3 |
| Config updates | 20 | 1 hour | 4 |
| Unit tests | 100 | 3 hours | 5 |
| **Total** | **~400** | **12 hours** | |

---

## Protocol 3: Spanning Tree Protocol (STP)

**Priority**: LOW (rarely needed in modern networks)
**Complexity**: MEDIUM
**Estimated Time**: 2-3 days
**Lines of Code**: ~200-300 lines

### Overview

STP prevents loops in Ethernet networks by:
- Electing a root bridge
- Calculating shortest path to root
- Blocking redundant paths

### BPDU (Bridge Protocol Data Unit) Format

```
Destination MAC: 01:80:C2:00:00:00 (STP multicast)
EtherType: 0x0004 (802.3 length field)
LLC: 0x42 0x42 0x03 (DSAP, SSAP, Control)

BPDU Fields:
- Protocol ID: 0x0000
- Version: 0x00 (STP) or 0x02 (RSTP)
- BPDU Type: 0x00 (Configuration)
- Flags
- Root Bridge ID
- Root Path Cost
- Bridge ID
- Port ID
- Message Age
- Max Age
- Hello Time
- Forward Delay
```

### Implementation Plan

#### Step 1: STP Handler

**File**: `pkg/protocols/stp.go`

```go
package protocols

const (
	STPMulticastMAC = "01:80:C2:00:00:00"
	STPEtherType    = 0x0004
)

type STPHandler struct {
	stack *Stack
}

func (h *STPHandler) HandleBPDU(packet gopacket.Packet) error {
	// 1. Parse BPDU
	// 2. Extract root bridge ID, path cost, bridge ID
	// 3. If device is configured as switch/bridge
	// 4. Send BPDU response
}

func (h *STPHandler) sendConfigurationBPDU(device *Device) error {
	// Build and send Configuration BPDU
}
```

#### Step 2: Update Device Config

```go
type Device struct {
	// ... existing fields
	BridgeID       string // ADD: for STP (8 bytes: priority + MAC)
	BridgePriority uint16 // ADD: default 32768
}
```

### Estimated Breakdown

| Task | Lines of Code | Time | Priority |
|------|---------------|------|----------|
| BPDU parser | 100 | 3 hours | 1 |
| Configuration BPDU sender | 100 | 3 hours | 2 |
| Config updates | 20 | 1 hour | 3 |
| Unit tests | 80 | 2 hours | 4 |
| **Total** | **~300** | **9 hours** | |

---

## Integration and Testing

### Phase 1: Individual Protocol Testing

1. **IPv6/ICMPv6**
   - Test ping6 from host to simulated device
   - Test NDP (Neighbor Discovery)
   - Verify multicast handling

2. **NetBIOS**
   - Test NetBIOS name queries
   - Verify name encoding/decoding

3. **STP**
   - Send BPDUs to simulated switches
   - Verify correct bridge ID and costs

### Phase 2: Full Integration Testing

1. Update `pkg/protocols/stack.go` to dispatch all protocols
2. Test all protocols simultaneously
3. Verify no regressions in existing protocols
4. Performance testing

### Phase 3: Example Configurations

Create comprehensive example configs in `examples/`:
- `ipv6-network.cfg` - IPv6-only network
- `dual-stack-network.cfg` - IPv4 + IPv6
- `netbios-network.cfg` - Windows network with NetBIOS
- `stp-network.cfg` - Switched network with STP

---

## Release Checklist

### Code Complete
- [ ] IPv6 handler implemented
- [ ] ICMPv6 handler implemented
- [ ] NetBIOS handler implemented
- [ ] STP handler implemented
- [ ] All handlers integrated into Stack
- [ ] Config file format updated
- [ ] Device struct updated

### Testing
- [ ] Unit tests written (target: 100+ new tests)
- [ ] Integration tests pass
- [ ] Manual testing with real traffic
- [ ] Performance benchmarks
- [ ] No regressions in v1.1.0 features

### Documentation
- [ ] Update README with new protocols
- [ ] Update JAVA_VS_GO_VALIDATION.md (13/13 score)
- [ ] Create example configs for new protocols
- [ ] Update ROADMAP.md
- [ ] Write v1.2.0 CHANGELOG entry

### Release Process
- [ ] Version bump to 1.2.0 in main.go
- [ ] Update BuildDate
- [ ] Build binary
- [ ] Run full test suite
- [ ] Create release commit
- [ ] Create v1.2.0 git tag with full release notes
- [ ] Update CHANGELOG.md

---

## Success Criteria

**v1.2.0 is successful when**:

1. ✅ All 3 protocols implemented and working
2. ✅ 100% feature parity with Java NIAC (13/13 categories)
3. ✅ All existing tests still pass
4. ✅ New protocols have comprehensive tests
5. ✅ Performance maintained or improved
6. ✅ Example configs demonstrate new protocols
7. ✅ Documentation updated
8. ✅ **Go NIAC definitively superior to Java in ALL categories**

---

## Risk Assessment

### High Risk Items
1. **IPv6 extension header parsing** - Complex, easy to get wrong
   - **Mitigation**: Thorough unit tests, reference Java implementation

2. **ICMPv6 NDP** - Critical for IPv6 functionality
   - **Mitigation**: Test with real IPv6 networks, wireshark capture analysis

### Medium Risk Items
1. **NetBIOS name encoding** - Unusual encoding scheme
   - **Mitigation**: Verify with Java implementation, create test vectors

2. **STP timing parameters** - Must match standard values
   - **Mitigation**: Use IEEE 802.1D standard values

### Low Risk Items
1. **Config file format** - Straightforward additions
2. **Performance** - New protocols similar to existing ones

---

## Timeline Estimate

| Phase | Duration | Dependencies |
|-------|----------|--------------|
| **Planning** (this document) | 1 day | None |
| **IPv6/ICMPv6 implementation** | 1-1.5 weeks | Planning complete |
| **NetBIOS implementation** | 3-5 days | IPv6 complete (can parallel) |
| **STP implementation** | 2-3 days | IPv6 complete (can parallel) |
| **Integration & Testing** | 3-4 days | All protocols complete |
| **Documentation & Release** | 1-2 days | Testing complete |
| **TOTAL** | **2.5-3.5 weeks** | |

**Aggressive Timeline**: 2 weeks (if no issues)
**Realistic Timeline**: 3 weeks (with buffer for issues)
**Conservative Timeline**: 4 weeks (with thorough testing)

---

**Next Steps**:
1. Review this plan with user
2. Start with IPv6/ICMPv6 (highest priority)
3. Implement, test, iterate
4. Move to NetBIOS, then STP
5. Final integration and release

**Last Updated**: January 5, 2025
